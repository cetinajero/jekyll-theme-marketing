{"version":3,"file":"firebase-app.js","sources":["../../node_modules/tslib/tslib.es6.js","../util/src/deepCopy.ts","../util/src/errors.ts","../util/src/subscribe.ts","../app/src/errors.ts","../app/src/constants.ts","../app/src/firebaseApp.ts","../app/src/firebaseNamespaceCore.ts","../app/index.ts","../app/src/firebaseNamespace.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Do a deep-copy of basic JavaScript Objects or Arrays.\n */\nexport function deepCopy<T>(value: T): T {\n  return deepExtend(undefined, value);\n}\n\n/**\n * Copy properties from source to target (recursively allows extension\n * of Objects and Arrays).  Scalar values in the target are over-written.\n * If target is undefined, an object of the appropriate type will be created\n * (and returned).\n *\n * We recursively copy all child properties of plain Objects in the source- so\n * that namespace- like dictionaries are merged.\n *\n * Note that the target can be a function, in which case the properties in\n * the source Object are copied onto it as static properties of the Function.\n */\nexport function deepExtend(target: any, source: any): any {\n  if (!(source instanceof Object)) {\n    return source;\n  }\n\n  switch (source.constructor) {\n    case Date:\n      // Treat Dates like scalars; if the target date object had any child\n      // properties - they will be lost!\n      let dateValue = (source as any) as Date;\n      return new Date(dateValue.getTime());\n\n    case Object:\n      if (target === undefined) {\n        target = {};\n      }\n      break;\n\n    case Array:\n      // Always copy the array source and overwrite the target.\n      target = [];\n      break;\n\n    default:\n      // Not a plain Object - treat it as a scalar.\n      return source;\n  }\n\n  for (let prop in source) {\n    if (!source.hasOwnProperty(prop)) {\n      continue;\n    }\n    target[prop] = deepExtend(target[prop], source[prop]);\n  }\n\n  return target;\n}\n\n// TODO: Really needed (for JSCompiler type checking)?\nexport function patchProperty(obj: any, prop: string, value: any) {\n  obj[prop] = value;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // Typescript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if (e.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\n\nexport type ErrorMap<ErrorCode extends string> = {\n  readonly [K in ErrorCode]: string\n};\n\nconst ERROR_NAME = 'FirebaseError';\n\nexport interface StringLike {\n  toString(): string;\n}\n\nexport interface ErrorData {\n  [key: string]: StringLike | undefined;\n}\n\nexport interface FirebaseError extends Error, ErrorData {\n  // Unique code for error - format is service/error-code-string.\n  readonly code: string;\n\n  // Developer-friendly error message.\n  readonly message: string;\n\n  // Always 'FirebaseError'.\n  readonly name: typeof ERROR_NAME;\n\n  // Where available - stack backtrace in a string.\n  readonly stack?: string;\n}\n\n// Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\nexport class FirebaseError extends Error {\n  readonly name = ERROR_NAME;\n\n  constructor(readonly code: string, message: string) {\n    super(message);\n\n    // Fix For ES5\n    // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, FirebaseError.prototype);\n\n    // Maintains proper stack trace for where our error was thrown.\n    // Only available on V8.\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ErrorFactory.prototype.create);\n    }\n  }\n}\n\nexport class ErrorFactory<ErrorCode extends string> {\n  constructor(\n    private readonly service: string,\n    private readonly serviceName: string,\n    private readonly errors: ErrorMap<ErrorCode>\n  ) {}\n\n  create(code: ErrorCode, data: ErrorData = {}): FirebaseError {\n    const fullCode = `${this.service}/${code}`;\n    const template = this.errors[code];\n\n    const message = template ? replaceTemplate(template, data) : 'Error';\n    // Service Name: Error message (service/code).\n    const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n\n    const error = new FirebaseError(fullCode, fullMessage);\n\n    // Keys with an underscore at the end of their name are not included in\n    // error.data for some reason.\n    // TODO: Replace with Object.entries when lib is updated to es2017.\n    for (const key of Object.keys(data)) {\n      if (key.slice(-1) !== '_') {\n        if (key in error) {\n          console.warn(\n            `Overwriting FirebaseError base field \"${key}\" can cause unexpected behavior.`\n          );\n        }\n        error[key] = data[key];\n      }\n    }\n\n    return error;\n  }\n}\n\nfunction replaceTemplate(template: string, data: ErrorData): string {\n  return template.replace(PATTERN, (_, key) => {\n    const value = data[key];\n    return value != null ? value.toString() : `<${key}?>`;\n  });\n}\n\nconst PATTERN = /\\{\\$([^}]+)}/g;\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type NextFn<T> = (value: T) => void;\nexport type ErrorFn = (error: Error) => void;\nexport type CompleteFn = () => void;\n\nexport interface Observer<T> {\n  // Called once for each value in a stream of values.\n  next: NextFn<T>;\n\n  // A stream terminates by a single call to EITHER error() or complete().\n  error: ErrorFn;\n\n  // No events will be sent to next() once complete() is called.\n  complete: CompleteFn;\n}\n\nexport type PartialObserver<T> = Partial<Observer<T>>;\n\n// TODO: Support also Unsubscribe.unsubscribe?\nexport type Unsubscribe = () => void;\n\n/**\n * The Subscribe interface has two forms - passing the inline function\n * callbacks, or a object interface with callback properties.\n */\nexport interface Subscribe<T> {\n  (next?: NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;\n  (observer: PartialObserver<T>): Unsubscribe;\n}\n\nexport interface Observable<T> {\n  // Subscribe method\n  subscribe: Subscribe<T>;\n}\n\nexport type Executor<T> = (observer: Observer<T>) => void;\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nexport function createSubscribe<T>(\n  executor: Executor<T>,\n  onNoObservers?: Executor<T>\n): Subscribe<T> {\n  let proxy = new ObserverProxy<T>(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\n\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy<T> implements Observer<T> {\n  private observers: Array<Observer<T>> | undefined = [];\n  private unsubscribes: Unsubscribe[] = [];\n  private onNoObservers: Executor<T> | undefined;\n  private observerCount = 0;\n  // Micro-task scheduling by calling task.then().\n  private task = Promise.resolve();\n  private finalized = false;\n  private finalError: Error;\n\n  /**\n   * @param executor Function which can make calls to a single Observer\n   *     as a proxy.\n   * @param onNoObservers Callback when count of Observers goes to zero.\n   */\n  constructor(executor: Executor<T>, onNoObservers?: Executor<T>) {\n    this.onNoObservers = onNoObservers;\n    // Call the executor asynchronously so subscribers that are called\n    // synchronously after the creation of the subscribe function\n    // can still receive the very first value generated in the executor.\n    this.task\n      .then(() => {\n        executor(this);\n      })\n      .catch(e => {\n        this.error(e);\n      });\n  }\n\n  next(value: T) {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.next(value);\n    });\n  }\n\n  error(error: Error) {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.error(error);\n    });\n    this.close(error);\n  }\n\n  complete() {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.complete();\n    });\n    this.close();\n  }\n\n  /**\n   * Subscribe function that can be used to add an Observer to the fan-out list.\n   *\n   * - We require that no event is sent to a subscriber sychronously to their\n   *   call to subscribe().\n   */\n  subscribe(\n    nextOrObserver: PartialObserver<T> | Function,\n    error?: ErrorFn,\n    complete?: CompleteFn\n  ): Unsubscribe {\n    let observer: Observer<T>;\n\n    if (\n      nextOrObserver === undefined &&\n      error === undefined &&\n      complete === undefined\n    ) {\n      throw new Error('Missing Observer.');\n    }\n\n    // Assemble an Observer object when passed as callback functions.\n    if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n      observer = nextOrObserver as Observer<T>;\n    } else {\n      observer = {\n        next: (nextOrObserver as any) as NextFn<T>,\n        error: error,\n        complete: complete\n      } as Observer<T>;\n    }\n\n    if (observer.next === undefined) {\n      observer.next = noop as NextFn<T>;\n    }\n    if (observer.error === undefined) {\n      observer.error = noop as ErrorFn;\n    }\n    if (observer.complete === undefined) {\n      observer.complete = noop as CompleteFn;\n    }\n\n    let unsub = this.unsubscribeOne.bind(this, this.observers!.length);\n\n    // Attempt to subscribe to a terminated Observable - we\n    // just respond to the Observer with the final error or complete\n    // event.\n    if (this.finalized) {\n      this.task.then(() => {\n        try {\n          if (this.finalError) {\n            observer.error(this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {\n          // nothing\n        }\n        return;\n      });\n    }\n\n    this.observers!.push(observer as Observer<T>);\n\n    return unsub;\n  }\n\n  // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n  private unsubscribeOne(i: number) {\n    if (this.observers === undefined || this.observers[i] === undefined) {\n      return;\n    }\n\n    delete this.observers[i];\n\n    this.observerCount -= 1;\n    if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n      this.onNoObservers(this);\n    }\n  }\n\n  private forEachObserver(fn: (observer: Observer<T>) => void): void {\n    if (this.finalized) {\n      // Already closed by previous event....just eat the additional values.\n      return;\n    }\n\n    // Since sendOne calls asynchronously - there is no chance that\n    // this.observers will become undefined.\n    for (let i = 0; i < this.observers!.length; i++) {\n      this.sendOne(i, fn);\n    }\n  }\n\n  // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n  private sendOne(i: number, fn: (observer: Observer<T>) => void): void {\n    // Execute the callback asynchronously\n    this.task.then(() => {\n      if (this.observers !== undefined && this.observers[i] !== undefined) {\n        try {\n          fn(this.observers[i]);\n        } catch (e) {\n          // Ignore exceptions raised in Observers or missing methods of an\n          // Observer.\n          // Log error to console. b/31404806\n          if (typeof console !== 'undefined' && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  }\n\n  private close(err?: Error): void {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    if (err !== undefined) {\n      this.finalError = err;\n    }\n    // Proxy is no longer needed - garbage collect references\n    this.task.then(() => {\n      this.observers = undefined;\n      this.onNoObservers = undefined;\n    });\n  }\n}\n\n/** Turn synchronous function into one called asynchronously. */\nexport function async(fn: Function, onError?: ErrorFn): Function {\n  return (...args: any[]) => {\n    Promise.resolve(true)\n      .then(() => {\n        fn(...args);\n      })\n      .catch((error: Error) => {\n        if (onError) {\n          onError(error);\n        }\n      });\n  };\n}\n\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj: any, methods: string[]): boolean {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  for (let method of methods) {\n    if (method in obj && typeof obj[method] === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction noop(): void {\n  // do nothing\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorFactory, ErrorMap } from '@firebase/util';\n\nexport const enum AppError {\n  NO_APP = 'no-app',\n  BAD_APP_NAME = 'bad-app-name',\n  DUPLICATE_APP = 'duplicate-app',\n  APP_DELETED = 'app-deleted',\n  DUPLICATE_SERVICE = 'duplicate-service',\n  INVALID_APP_ARGUMENT = 'invalid-app-argument'\n}\n\nconst ERRORS: ErrorMap<AppError> = {\n  [AppError.NO_APP]:\n    \"No Firebase App '{$name}' has been created - \" +\n    'call Firebase App.initializeApp()',\n  [AppError.BAD_APP_NAME]: \"Illegal App name: '{$name}\",\n  [AppError.DUPLICATE_APP]: \"Firebase App named '{$name}' already exists\",\n  [AppError.APP_DELETED]: \"Firebase App named '{$name}' already deleted\",\n  [AppError.DUPLICATE_SERVICE]:\n    \"Firebase service named '{$name}' already registered\",\n  [AppError.INVALID_APP_ARGUMENT]:\n    'firebase.{$name}() takes either no argument or a ' +\n    'Firebase App instance.'\n};\n\nconst appErrors = new ErrorFactory<AppError>('app', 'Firebase', ERRORS);\n\nexport function error(code: AppError, args?: { [name: string]: any }) {\n  throw appErrors.create(code, args);\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const DEFAULT_ENTRY_NAME = '[DEFAULT]';\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  FirebaseApp,\n  FirebaseOptions,\n  FirebaseAppConfig\n} from '@firebase/app-types';\nimport {\n  _FirebaseApp,\n  _FirebaseNamespace,\n  FirebaseService,\n  FirebaseAppInternals\n} from '@firebase/app-types/private';\nimport { deepCopy, deepExtend } from '@firebase/util';\nimport { error, AppError } from './errors';\nimport { DEFAULT_ENTRY_NAME } from './constants';\n\ninterface ServicesCache {\n  [name: string]: {\n    [serviceName: string]: FirebaseService;\n  };\n}\n\n// An array to capture listeners before the true auth functions\n// exist\nlet tokenListeners: any[] = [];\n\n/**\n * Global context object for a collection of services using\n * a shared authentication state.\n */\nexport class FirebaseAppImpl implements FirebaseApp {\n  private readonly options_: FirebaseOptions;\n  private readonly name_: string;\n  private isDeleted_ = false;\n  private services_: ServicesCache = {};\n  private automaticDataCollectionEnabled_: boolean;\n\n  INTERNAL: FirebaseAppInternals;\n\n  constructor(\n    options: FirebaseOptions,\n    config: FirebaseAppConfig,\n    private readonly firebase_: _FirebaseNamespace\n  ) {\n    this.name_ = config.name!;\n    this.automaticDataCollectionEnabled_ =\n      config.automaticDataCollectionEnabled || false;\n    this.options_ = deepCopy<FirebaseOptions>(options);\n    this.INTERNAL = {\n      getUid: () => null,\n      getToken: () => Promise.resolve(null),\n      addAuthTokenListener: (callback: (token: string | null) => void) => {\n        tokenListeners.push(callback);\n        // Make sure callback is called, asynchronously, in the absence of the auth module\n        setTimeout(() => callback(null), 0);\n      },\n      removeAuthTokenListener: callback => {\n        tokenListeners = tokenListeners.filter(\n          listener => listener !== callback\n        );\n      }\n    };\n  }\n\n  get automaticDataCollectionEnabled(): boolean {\n    this.checkDestroyed_();\n    return this.automaticDataCollectionEnabled_;\n  }\n\n  set automaticDataCollectionEnabled(val) {\n    this.checkDestroyed_();\n    this.automaticDataCollectionEnabled_ = val;\n  }\n\n  get name(): string {\n    this.checkDestroyed_();\n    return this.name_;\n  }\n\n  get options(): FirebaseOptions {\n    this.checkDestroyed_();\n    return this.options_;\n  }\n\n  delete(): Promise<void> {\n    return new Promise(resolve => {\n      this.checkDestroyed_();\n      resolve();\n    })\n      .then(() => {\n        this.firebase_.INTERNAL.removeApp(this.name_);\n        const services: FirebaseService[] = [];\n\n        for (const serviceKey of Object.keys(this.services_)) {\n          for (const instanceKey of Object.keys(this.services_[serviceKey])) {\n            services.push(this.services_[serviceKey][instanceKey]);\n          }\n        }\n\n        return Promise.all(\n          services.map(service => {\n            return service.INTERNAL.delete();\n          })\n        );\n      })\n      .then(\n        (): void => {\n          this.isDeleted_ = true;\n          this.services_ = {};\n        }\n      );\n  }\n\n  /**\n   * Return a service instance associated with this app (creating it\n   * on demand), identified by the passed instanceIdentifier.\n   *\n   * NOTE: Currently storage is the only one that is leveraging this\n   * functionality. They invoke it by calling:\n   *\n   * ```javascript\n   * firebase.app().storage('STORAGE BUCKET ID')\n   * ```\n   *\n   * The service name is passed to this already\n   * @internal\n   */\n  _getService(\n    name: string,\n    instanceIdentifier: string = DEFAULT_ENTRY_NAME\n  ): FirebaseService {\n    this.checkDestroyed_();\n\n    if (!this.services_[name]) {\n      this.services_[name] = {};\n    }\n\n    if (!this.services_[name][instanceIdentifier]) {\n      /**\n       * If a custom instance has been defined (i.e. not '[DEFAULT]')\n       * then we will pass that instance on, otherwise we pass `null`\n       */\n      const instanceSpecifier =\n        instanceIdentifier !== DEFAULT_ENTRY_NAME\n          ? instanceIdentifier\n          : undefined;\n      const service = this.firebase_.INTERNAL.factories[name](\n        this,\n        this.extendApp.bind(this),\n        instanceSpecifier\n      );\n      this.services_[name][instanceIdentifier] = service;\n    }\n\n    return this.services_[name][instanceIdentifier];\n  }\n\n  /**\n   * Callback function used to extend an App instance at the time\n   * of service instance creation.\n   */\n  private extendApp(props: { [name: string]: any }): void {\n    // Copy the object onto the FirebaseAppImpl prototype\n    deepExtend(this, props);\n\n    /**\n     * If the app has overwritten the addAuthTokenListener stub, forward\n     * the active token listeners on to the true fxn.\n     *\n     * TODO: This function is required due to our current module\n     * structure. Once we are able to rely strictly upon a single module\n     * implementation, this code should be refactored and Auth should\n     * provide these stubs and the upgrade logic\n     */\n    if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {\n      tokenListeners.forEach(listener => {\n        this.INTERNAL.addAuthTokenListener(listener);\n      });\n      tokenListeners = [];\n    }\n  }\n\n  /**\n   * This function will throw an Error if the App has already been deleted -\n   * use before performing API actions on the App.\n   */\n  private checkDestroyed_(): void {\n    if (this.isDeleted_) {\n      error(AppError.APP_DELETED, { name: this.name_ });\n    }\n  }\n}\n\n// Prevent dead-code elimination of these methods w/o invalid property\n// copying.\n(FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options) ||\n  FirebaseAppImpl.prototype.delete ||\n  console.log('dc');\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  FirebaseApp,\n  FirebaseOptions,\n  FirebaseNamespace,\n  FirebaseAppConfig\n} from '@firebase/app-types';\nimport {\n  _FirebaseApp,\n  _FirebaseNamespace,\n  FirebaseService,\n  FirebaseServiceFactory,\n  FirebaseServiceNamespace,\n  AppHook\n} from '@firebase/app-types/private';\nimport { deepExtend, patchProperty } from '@firebase/util';\nimport { FirebaseAppImpl } from './firebaseApp';\nimport { error, AppError } from './errors';\nimport { FirebaseAppLiteImpl } from './lite/firebaseAppLite';\nimport { DEFAULT_ENTRY_NAME } from './constants';\n\nfunction contains(obj: object, key: string) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\n/**\n * Because auth can't share code with other components, we attach the utility functions\n * in an internal namespace to share code.\n * This function return a firebase namespace object without\n * any utility functions, so it can be shared between the regular firebaseNamespace and\n * the lite version.\n */\nexport function createFirebaseNamespaceCore(\n  firebaseAppImpl: typeof FirebaseAppImpl | typeof FirebaseAppLiteImpl\n): FirebaseNamespace {\n  const apps: { [name: string]: FirebaseApp } = {};\n  const factories: { [service: string]: FirebaseServiceFactory } = {};\n  const appHooks: { [service: string]: AppHook } = {};\n\n  // A namespace is a plain JavaScript Object.\n  const namespace: FirebaseNamespace = {\n    // Hack to prevent Babel from modifying the object returned\n    // as the firebase namespace.\n    // @ts-ignore\n    __esModule: true,\n    initializeApp: initializeApp,\n    app: app as any,\n    apps: null as any,\n    SDK_VERSION: '${JSCORE_VERSION}',\n    INTERNAL: {\n      registerService,\n      removeApp,\n      factories,\n      useAsService\n    }\n  };\n\n  // Inject a circular default export to allow Babel users who were previously\n  // using:\n  //\n  //   import firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase').default;\n  //\n  // instead of\n  //\n  //   import * as firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase');\n  patchProperty(namespace, 'default', namespace);\n\n  // firebase.apps is a read-only getter.\n  Object.defineProperty(namespace, 'apps', {\n    get: getApps\n  });\n\n  /**\n   * Called by App.delete() - but before any services associated with the App\n   * are deleted.\n   */\n  function removeApp(name: string): void {\n    const app = apps[name];\n    callAppHooks(app, 'delete');\n    delete apps[name];\n  }\n\n  /**\n   * Get the App object for a given name (or DEFAULT).\n   */\n  function app(name?: string): FirebaseApp {\n    name = name || DEFAULT_ENTRY_NAME;\n    if (!contains(apps, name)) {\n      error(AppError.NO_APP, { name: name });\n    }\n    return apps[name];\n  }\n\n  patchProperty(app, 'App', firebaseAppImpl);\n  /**\n   * Create a new App instance (name must be unique).\n   */\n  function initializeApp(\n    options: FirebaseOptions,\n    config?: FirebaseAppConfig\n  ): FirebaseApp;\n  function initializeApp(options: FirebaseOptions, name?: string): FirebaseApp;\n  function initializeApp(options: FirebaseOptions, rawConfig = {}) {\n    if (typeof rawConfig !== 'object' || rawConfig === null) {\n      const name = rawConfig;\n      rawConfig = { name };\n    }\n\n    const config = rawConfig as FirebaseAppConfig;\n\n    if (config.name === undefined) {\n      config.name = DEFAULT_ENTRY_NAME;\n    }\n\n    const { name } = config;\n\n    if (typeof name !== 'string' || !name) {\n      error(AppError.BAD_APP_NAME, { name: String(name) });\n    }\n\n    if (contains(apps, name)) {\n      error(AppError.DUPLICATE_APP, { name: name });\n    }\n\n    const app = new firebaseAppImpl(\n      options,\n      config,\n      namespace as _FirebaseNamespace\n    );\n\n    apps[name] = app;\n    callAppHooks(app, 'create');\n\n    return app;\n  }\n\n  /*\n   * Return an array of all the non-deleted FirebaseApps.\n   */\n  function getApps(): FirebaseApp[] {\n    // Make a copy so caller cannot mutate the apps list.\n    return Object.keys(apps).map(name => apps[name]);\n  }\n\n  /*\n   * Register a Firebase Service.\n   *\n   * firebase.INTERNAL.registerService()\n   *\n   * TODO: Implement serviceProperties.\n   */\n  function registerService(\n    name: string,\n    createService: FirebaseServiceFactory,\n    serviceProperties?: { [prop: string]: unknown },\n    appHook?: AppHook,\n    allowMultipleInstances = false\n  ): FirebaseServiceNamespace<FirebaseService> {\n    // Cannot re-register a service that already exists\n    if (factories[name]) {\n      error(AppError.DUPLICATE_SERVICE, { name: name });\n    }\n\n    // Capture the service factory for later service instantiation\n    factories[name] = createService;\n\n    // Capture the appHook, if passed\n    if (appHook) {\n      appHooks[name] = appHook;\n\n      // Run the **new** app hook on all existing apps\n      getApps().forEach(app => {\n        appHook('create', app);\n      });\n    }\n\n    // The Service namespace is an accessor function ...\n    function serviceNamespace(appArg: FirebaseApp = app()) {\n      if (typeof appArg[name] !== 'function') {\n        // Invalid argument.\n        // This happens in the following case: firebase.storage('gs:/')\n        error(AppError.INVALID_APP_ARGUMENT, { name: name });\n      }\n\n      // Forward service instance lookup to the FirebaseApp.\n      return appArg[name]();\n    }\n\n    // ... and a container for service-level properties.\n    if (serviceProperties !== undefined) {\n      deepExtend(serviceNamespace, serviceProperties);\n    }\n\n    // Monkey-patch the serviceNamespace onto the firebase namespace\n    namespace[name] = serviceNamespace;\n\n    // Patch the FirebaseAppImpl prototype\n    firebaseAppImpl.prototype[name] = function(...args) {\n      const serviceFxn = this._getService.bind(this, name);\n      return serviceFxn.apply(this, allowMultipleInstances ? args : []);\n    };\n\n    return serviceNamespace;\n  }\n\n  function callAppHooks(app: FirebaseApp, eventName: string) {\n    for (const serviceName of Object.keys(factories)) {\n      // Ignore virtual services\n      const factoryName = useAsService(app, serviceName);\n      if (factoryName === null) {\n        return;\n      }\n\n      if (appHooks[factoryName]) {\n        appHooks[factoryName](eventName, app);\n      }\n    }\n  }\n\n  // Map the requested service to a registered service name\n  // (used to map auth to serverAuth service when needed).\n  function useAsService(app: FirebaseApp, name: string): string | null {\n    if (name === 'serverAuth') {\n      return null;\n    }\n\n    const useService = name;\n\n    return useService;\n  }\n\n  return namespace;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseNamespace } from '@firebase/app-types';\nimport { createFirebaseNamespace } from './src/firebaseNamespace';\n\n// Node detection logic from: https://github.com/iliakan/detect-node/\nlet isNode = false;\ntry {\n  isNode =\n    Object.prototype.toString.call(global.process) === '[object process]';\n} catch (e) {}\n\nisNode &&\n  console.warn(`\nWarning: This is a browser-targeted Firebase bundle but it appears it is being\nrun in a Node environment.  If running in a Node environment, make sure you\nare using the bundle specified by the \"main\" field in package.json.\n\nIf you are using Webpack, you can specify \"main\" as the first item in\n\"resolve.mainFields\":\nhttps://webpack.js.org/configuration/resolve/#resolvemainfields\n\nIf using Rollup, use the rollup-plugin-node-resolve plugin and set \"module\"\nto false and \"main\" to true:\nhttps://github.com/rollup/rollup-plugin-node-resolve\n`);\n\n// Firebase Lite detection\nif (self && 'firebase' in self) {\n  console.warn(`\n    Warning: Firebase is already defined in the global scope. Please make sure\n    Firebase library is only loaded once.\n  `);\n\n  const sdkVersion = ((self as any).firebase as FirebaseNamespace).SDK_VERSION;\n  if (sdkVersion && sdkVersion.indexOf('LITE') >= 0) {\n    console.warn(`\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\n    `);\n  }\n}\n\nexport const firebase = createFirebaseNamespace();\n\nexport default firebase;\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseNamespace } from '@firebase/app-types';\nimport { _FirebaseApp, _FirebaseNamespace } from '@firebase/app-types/private';\nimport { createSubscribe, deepExtend, ErrorFactory } from '@firebase/util';\nimport { FirebaseAppImpl } from './firebaseApp';\nimport { createFirebaseNamespaceCore } from './firebaseNamespaceCore';\n\n/**\n * Return a firebase namespace object.\n *\n * In production, this will be called exactly once and the result\n * assigned to the 'firebase' global.  It may be called multiple times\n * in unit tests.\n */\nexport function createFirebaseNamespace(): FirebaseNamespace {\n  const namespace = createFirebaseNamespaceCore(FirebaseAppImpl);\n  (namespace as _FirebaseNamespace).INTERNAL = {\n    ...(namespace as _FirebaseNamespace).INTERNAL,\n    createFirebaseNamespace: createFirebaseNamespace,\n    extendNamespace: extendNamespace,\n    createSubscribe: createSubscribe,\n    ErrorFactory: ErrorFactory,\n    deepExtend: deepExtend\n  };\n\n  /**\n   * Patch the top-level firebase namespace with additional properties.\n   *\n   * firebase.INTERNAL.extendNamespace()\n   */\n  function extendNamespace(props: { [prop: string]: unknown }): void {\n    deepExtend(namespace, props);\n  }\n\n  return namespace;\n}\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__assign","assign","t","s","i","n","arguments","length","prototype","call","apply","this","deepExtend","target","source","constructor","Date","getTime","undefined","prop","patchProperty","obj","value","code","message","_super","_this","FirebaseError","Error","captureStackTrace","ErrorFactory","create","__","tslib_1.__extends","service","serviceName","errors","data","fullCode","template","replace","PATTERN","_","key","toString","fullMessage","error","_a","keys","_i","slice","console","warn","createSubscribe","executor","onNoObservers","proxy","ObserverProxy","subscribe","bind","Promise","resolve","task","then","catch","e","forEachObserver","observer","next","close","complete","nextOrObserver","methods","methods_1","method","implementsAnyMethods","noop","unsub","unsubscribeOne","observers","finalized","finalError","push","observerCount","fn","sendOne","err","ERRORS","appErrors","args","DEFAULT_ENTRY_NAME","tokenListeners","options","config","firebase_","name_","name","automaticDataCollectionEnabled_","automaticDataCollectionEnabled","options_","INTERNAL","getUid","getToken","addAuthTokenListener","callback","setTimeout","removeAuthTokenListener","filter","listener","FirebaseAppImpl","checkDestroyed_","val","removeApp","services","services_","serviceKey","_c","_b","instanceKey","all","map","delete","isDeleted_","instanceIdentifier","instanceSpecifier","factories","extendApp","props","forEach","contains","log","isNode","global","process","self","sdkVersion","firebase","SDK_VERSION","indexOf","createFirebaseNamespace","namespace","firebaseAppImpl","apps","appHooks","__esModule","initializeApp","rawConfig","name_1","String","app","callAppHooks","registerService","createService","serviceProperties","appHook","allowMultipleInstances","serviceNamespace","appArg","getApps","_getService","useAsService","eventName","factoryName","defineProperty","get","createFirebaseNamespaceCore","extendNamespace"],"mappings":"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"}